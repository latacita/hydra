%%==================================================================%%
%% Author : Tejedo GonzÁlez, Daniel                                 %%
%%          Sánchez Barreiro, Pablo                                 %%
%% Version: 1.0, 22/11/2012                                         %%
%% Version: 2.0, 31/01/2013                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Planificacion, planificacion                                     %%
%%==================================================================%%

Como se ha comentado con anterioridad, el objetivo de este Proyecto Fin de Carrera es el desarrollo de un editor para un novedoso lenguaje de especificación y validación de restricciones para árboles de características donde dichas restricciones puedan incluir características clonables. Dicho editor se desarrollará utilizando un moderno enfoque de \emph{Ingeniería de Lenguajes Dirigido por Modelos}. Por tanto, el proceso de desarrollo del presente proyecto queda prácticamente determinado por dicho enfoque, el cual posee un proceso de desarrollo bien definido, el cual se describió en la sección anterior. La Figura~\ref{fig:planning} muestra como dicho proceso de desarrollo se ha instanciado para nuestro caso particular.

%%==================================================================%%
%% NOTA(Pablo): En esta imagen hay que hacer cambios                %%
%%              Te los indico de foma verbal cuando pases por el    %%
%%              despacho, pero hay que mejorar su consistencia      %%
%%==================================================================%%

\begin{figure}[!tb]
    \includegraphics[scale=0.74]{planificacion/planning.eps}
    \caption{Proceso de desarrollo del Proyecto Fin de Carrera}
    \label{fig:planning}
\end{figure}

Obviamente, la primera tarea (Figura~\ref{fig:planning}-\emph{T1}) en este proceso de desarrollo fue la de adquirir los conocimientos necesarios para la realización de todas las tareas posteriores. Ello implicaba adquirir los conocimientos relacionados con las \emph{Líneas de Producto Software}~\cite{pohl:2005, kakola:2006} en general y con los árboles de características~\cite{czarnecky:2005} en particular, más concretamente, con la versión de los árboles de características que soportan la definición de características clonables~\cite{czarnecky:2005, batory:2005}. Dado que el proyecto se debía integrar con una herramienta para la especificación y configuración de árboles de características concreta, denominada \emph{Hydra}~\cite{}, el siguiente paso fue el de familiarizarse con dicha herramienta y adquirir ciertos conocimientos sobre su arquitectura interna.

A continuación, se tuvieron que adquirir los conceptos necesarios para entender el funcionamiento de de la \emph{Ingeniería de Lenguajes Dirigida por Modelos}~\cite{anneke:2008}. La familiarización con las tecnologías concretas relacionadas con la \emph{Ingeniería de Lenguajes Dirigida por Modelos}, como la utilización de EMF (\emph{Eclipse Modelling Framework})~\cite{steinberg:2008} para la definición de metamodelos, se realizó dentro de cada fase concreta del proyecto, a medida que se iba necesitando aprender a utilizar dichas tecnologías.

%%========================================================================================%%
%% NOTA(Pablo): No pongas los tiempos que te ha costado cada tarea. Normalmente, no
%%              interesa y da mala imagen
%%========================================================================================%%

Tras esta tarea inicial de adquisición de conocimientos previos, el resto del proyecto se estructura como un proyecto de desarrollo de un lenguaje software siguiendo un enfoque dirigido por modelos. Consecuentemente, la primera tarea tras la fase inicial de documentación (Figura~\ref{fig:planning}-\emph{T2}) fue la definición de la sintaxis abstracta, por medio de un metamodelo sumado a un conjunto de restricciones externas para el lenguaje que debía soportar nuestro editor. Para ello tuvimos que capturar los requisitos que debía satisfacer dicho lenguaje. Tras recoger dichos requisitos, se procedió al diseño del metamodelo y a la relización de las pruebas pertinentes con vistas a comprobar su correcto funcionamiento. Para crear dicho metamodelo se utilizó el lenguaje de metamodelado Ecore, integrado dentro de la herramienta EMF (Eclipse Modelling Framework)~\cite{steinberg:2008}.

A continuación, de acuerdo con los expuesto en la sección anterior, procedimos a definir la las restricciones externas que no podían ser definidas en Ecore (Figura~\ref{fig:planning}-\emph{T3}). Dichas restricciones se implementaron utilizando la facilidad de EMF denominada EMF Validation Framework~\cite{steinberg:2008}.

A continuación, procedimos a definir la sintaxis concreta, en nuestro caso textual, para nuestro lenguaje de modelado. Optamos por una sintaxis textual ya que las restricciones a especificar son similares a las fórmulas lógicas, las cuales resultan más cómodas de especificar mediante notaciones textuales que mediante notaciones gráficas (Figura~\ref{fig:planning}-\emph{T4}). Para el desarrollo de dicha sintaxis textual hubo que hacer un nuevo análisis de los requisitos que dicha notación textual debía satisfacer. A continuación se especificó la gramática de nuestra sintaxis textual, ligando sus elementos con los del metamodelo producido en la fase anterior y se ejecutaron los casos de prueba necesarios para comprobar su correcto funcionamiento. Para crear dicha sintaxis textual se utilizó la herramienta EMFText~\cite{}.

Las etapas anteriores permitían disponer de un editor que soportaba la especificación de restricciones de acuerdo al lenguaje HCL. Por tanto, sólo restaba poder comprobar, para una configuración dada de un árbol de características, que dichas restricciones se satisfacían. Ello implicaba dotar de semántica al lenguaje y, a partir de dicha semántica, implementar los mecanismos necesarios para la comprobación de la validez de dichas restricciones. La semántica del lenguaje ya estaba definida por el profesor Pablo Sánchez, por lo que sólo hubo que implementar el código necesario para procesar un modelo de restricciones y comprobar que dichas restricciones se satisfacían. Dicho código se implementó en Java, utilizando las facilidades que el entorno EMF proporciona para la manipulación del modelo  (Figura~\ref{fig:planning}-\emph{T5}). Para poder implementar la semántica, fue necesario crear una interfaz de comunicación con la herramienta \emph{Hydra} que permitiese conocer el estado en el cual se hallaba cada característica. Tras la implementación, se ejecutó un exhaustivo conjunto de pruebas para comprobar el correcto funcionamiento del código creado.

En este punto del proceso de desarrollo teníamos implementado el editor requerido, por lo que sólo restaba proceder a su despliegue (Figura~\ref{fig:planning}-\emph{T6}). Este despliegue implicaba su integración dentro de la arquitectura de plugins de Eclipse y, más concretamente, de la herramienta \emph{Hydra}. Tras dicha integración, se procedió a realizar una serie de pruebas de aceptación, destinadas a comprobar que el trabajo realizado satisfacía las necesidades de los usuarios finales que iban a utilizar el editor creado.

