%%==================================================================%%
%% Author : Tejedo GonzÁlez, Daniel                                 %%
%%          Sánchez Barreiro, Pablo                                 %%
%% Version: 1.0, 18/11/2012                                         %%
%% Version: 1.0, 30/01/2013                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Introduction/Ingeniería de lenguajes dirigidos por modelos       %%
%%==================================================================%%

Este proyecto ha sido desarrollado siguiendo un enfoque de \emph{Ingeniería de Lenguajes Dirigida por Modelos}, la cual establece unas etapas claras para el proceso de desarrollo de un nuevo lenguaje software. Por tanto, antes de proceder a explicar la planificación del presente proyecto se hace necesario adquirir unas nociones básicas sobre la Ingeniería de Lenguajes Dirigida por Modelos, de forma que se pueda entender por qué el presente proyecto se organiza tal como se organiza.

La \emph{Ingeniería de Lenguajes Dirigida por Modelos}~\cite{} no es más que un caso concreto de la más genérica \emph{Ingeniería Software Dirigida por Modelos}~\cite{} aplicado desde el punto de vista de la \emph{Teoría de Lenguajes Formales}.

%%===========================================================================================%%
%% NOTA(Pablo): No metas paja por meter, vamos a explicar directamente qué es la Inegniería  %%
%%              de lenguajes dirigida por modelos                                            %%
%%===========================================================================================%%
%%
%% Por tanto, con lo cual es conveniente explicar en qué consiste MDA y comentar los         %%
%% añadidos que introduce el enfoque gramático.                                              %%  %%
%% La Ingeniería Dirigida por Modelos intenta definir la funcionalidad de el sistema que
%% pretendemos crear a través de la creación de uno o varios metamodelos que representen
%% todas las características de nuestro sistema y todas las operaciones que puede llevar
%% a cabo. El principal objetivo de la Ingeniería Dirigida por Modelos es elevar el nivel
%% de abstracción aún más, situándolo por encima del límite establecido por los
%% Lenguajes de Alto Nivel.
%%
%%
%% El nivel de abstracción y complejidad de nuestros metamodelos variará dependiendo de
%% la cantidad de ellos que incorporemos al sistema. De este modo, un metamodelo que
%% represente todo el sistema directamente será más difícil de entender a primera vista
%% que varios metamodelos que implementen cada uno un tipo de operación o funcionalidad
%% del sistema.
%%
%% La transformación de esos modelos a código permite la automatización de tareas que
%% pueden resultar triviales y/o repetitivas al programador, en las cuales de otro modo
%% se invierte mucho tiempo de programación y de detección y depuración de errores.
%%
%%
%% Una vez que tengamos los metamodelos necesarios para definir el comportamiento de
%% nuestro sistema, podremos instanciarlos para crear modelos que representen sistemas
%% concretos. Una instancia de un metamodelo es un modelo que cumple todos los
%% requisitos marcados por su metamodelo, y que da valor a los parámetros del mismo
%%  (por ejemplo a sus atributos).
%%
%%===========================================================================================%%

%%===========================================================================================%%
%% NOTA(Pablo): Copia aquí la Sección 2.2 que aparece en la memoria de Hydra, disponible
%%              aquí: http://caosd.lcc.uma.es/spl/hydra/documents/PFC_JRSalazar.pdf
%%              Rehaz la Figura 2.9 en Visio o similar, y quitale la línea rizada.
%%===========================================================================================%%

\begin{figure}[!tb]
    \includegraphics[scale=0.5]{background/abstracta.eps}
    \caption{Metamodelo (sintaxis abstracta) de un lenguaje para modelar grafos pesados dirigidos}
    \label{fig:sle:metamodeloGrafo}
\end{figure}

Ilustramos los conceptos anteriormente expuestos mediante la creación de un lenguaje simple para el modelado de grafos dirigidos y pesados. La Figura~\ref{fig:sle:metamodeloGrafo} muestra el metamodelo o sintaxis abstracta para dicho lenguaje. La clase \emph{Grafo} actúa como contenedor para el resto de los elementos. Representa un como conjunto de \emph{Nodos} y \emph{Arcos}. Los nodos poseen nombre, que permite distinguirlos uno de otros. Dichos nodos pueden estar conectados por arcos dirigidos, por lo que cada arco tiene un nodo origen y un nodo destino. Dado que el grafo es pesado, cada noto tiene además un peso.

%%===========================================================================================%%
%% NOTA(Pablo): Esto es redundate, es decir, básicamente paja para rellenar                  %%
%%===========================================================================================%%
%%
%% En el ejemplo presentado, el metamodelo presenta la sintaxis abstracta de nuestro
%% sistema porque cualquier instanciación válida del mismo constituye un grafo completo.
%% Dentro del contexto particular de la Ingeniería de Lenguajes Dirigida por Modelos, la
%% sintaxis abstracta representa cualquier conjunto de líneas de código válidas que pueden
%% construirse a partir de ella, y posteriormente ser ejecutadas.
%%
%%===========================================================================================%%

%%===========================================================================================%%
%% NOTA(Pablo): En esta figura pega los nombres de las referencias y las multiplicidades a   %%
%%              los extremos de las asociaciones                                             %% %%===========================================================================================%%

\begin{figure}[!tb]
    \includegraphics[scale=0.5]{background/concreta.eps}
    \caption{Modelo abstacto de un grafo pesado dirigido concreto.}
    \label{fig:sle:modeloAbstractoGrafo}
\end{figure}

Utilizando dicho metamodelo, que no es más que un diagrama de clases, podemos crear instancias del mismo. Una instancia de un metamodelo es un modelo. En nuestro caso, cada instancia concreta del metamodelo de la Figura~\ref{fig:sle:metamodeloGrafo} representaría un determinado grafo pesado dirigido, con un número determinado de nodos, pesos y arcos. Por ejemplo, la Figura~\ref{fig:sle:modeloAbstractoGrafo} muestra una instancia del metamodelo de la Figura~\ref{fig:sle:metamodeloGrafo} que representa un grafo dirigido y pesado que modela las distancias \todo{Cambiar Ejemplo} entre las ciudades de Santander, Barcelona y La Coruña. Cada ciudad se representa como un nodo, y

%%===========================================================================================%%
%% NOTA(Pablo): Este ejemplo no es el mejor ejemplo de nodo dirigido, porque las distancias  %%
%%              entre ciudades son simétricas, es decir, si la distancia entre Barcelona y   %%
%%              Santander es de 600km, entre Santander y Barcelona también es de 600         %% %%===========================================================================================%%

%%===========================================================================================%%
%% NOTA(Pablo): Demasiado especializado                                                      %%     %%===========================================================================================%%
%%
%% Pero no sólo eso, el hecho de que estemos trabajando con lenguajes conlleva 
%% irrevocablemente el tener que desarrollar una gramática de producciones para poder 
%% construir nuestras líneas de código en el orden apropiado y con los símbolos apropiados. 
%% Eso sí, la gramática será más sencilla y comprensible que la que habría que construir 
%% de no estar usando este tipo de metodología. Esta tarea también queda englobada en la
%% sintaxis concreta. De este modo, la sintaxis concreta se suele clasificar en sintaxis 
%% concreta visual (el modelo, expresado mediante líneas de código en el caso de lenguajes, 
%% o un grafo pintado en el caso del ejemplo mostrado) y sintaxis concreta textual (la 
%% gramática del lenguaje).
%%
%%===========================================================================================%%

Como se ha ilustrado con los ejemplos anteriores, un metamodelo define un conjunto de reglas que debe obedecer todo modelo que pertenezca al lenguaje definido por dicho metamodelo. Por tanto, usando términos más técnicos, un metamodelo define la sintaxis abstracta de un lenguaje. Dicha sintaxis abstracta será similar a los árboles sintacticos de los lenguajes de programación tradicionales. No obstante, para que el lenguaje definido por un metamodelo sea fácilmente utilizable,  


La figura \ref{fig3} muestra una sintaxis concreta visual del grafo de la figura \ref{fig2}.

\begin{figure}[t]
\includegraphics[scale=0.5]{background/grafo.eps}
\caption{Sintaxis visual del grafo de la figura \ref{fig2}}
\label{fig:sle:sintaxisConcreta}
\end{figure}

Una vez que hemos completado estos pasos, sólamente queda dotar al sistema de una semántica, es decir, de un comportamiento en ejecución. En el ejemplo de nuestro generador de grafos podríamos crear una semántica para calcular distancias mínimas entre caminos. En el caso concreto de la Ingeniería de Lenguajes Dirigida por Modelos esta semántica representa el comportamiento de las líneas de código cuando son ejecutadas. Por poner un ejemplo sencillo, es la encargada de que la instrucción "4 < 5" compruebe si efectivamente el 4 es menor que el 5.

Una vez se han explicado las bases de la Ingeniería de Lenguajes Dirigida por Modelos vamos a proceder a mostrar y explicar muy brevemente el metamodelo usado para generar las estructuras válidas de código para el lenguaje de especificación y validación de restricciones que hemos creado en este PFC. Ese metamodelo corresponde a la figura \ref{fig4}

\begin{figure}[t]
\includegraphics[scale=0.4]{background/metamodelo.eps}
\caption{Metamodelo utilizado para la creación de nuestro lenguaje de especificación y validación de restricciones}
\label{fig4}
\end{figure}

La clase que engloba todo el conjunto resultante es Model. Un modelo puede tener varias restricciones, y estas a su vez pueden tener varias operaciones booleanas (ya que una restricción siempre tiene que evaluarse a true o false). Esas operaciones booleanas se dividen en varios tipos: unarias (negación) , binarias (and, or, etc.), de comparación ( mayor que, menor que, etc.). o de selección (all, any)  Los operandos pueden ser otras operaciones o características (en inglés Features). Más adelante se explicará en detalle la sintaxis del lenguaje creado.










