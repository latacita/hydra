%%==================================================================%%
%% Author : Tejedo GonzÁlez, Daniel                                 %%
%%          Sánchez Barreiro, Pablo                                 %%
%% Version: 1.0, 18/11/2012                                         %%
%% Version: 1.0, 30/01/2013                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Introduction/Ingeniería de lenguajes dirigidos por modelos       %%
%%==================================================================%%

Este proyecto ha sido desarrollado siguiendo un enfoque de \emph{Ingeniería de Lenguajes Dirigida por Modelos}, la cual establece unas etapas claras para el proceso de desarrollo de un nuevo lenguaje software. Por tanto, antes de proceder a explicar la planificación del presente proyecto se hace necesario adquirir unas nociones básicas sobre la Ingeniería de Lenguajes Dirigida por Modelos, de forma que se pueda entender por qué el presente proyecto se organiza tal como se organiza.

La \emph{Ingeniería de Lenguajes Dirigida por Modelos}~\cite{} no es más que un caso concreto de la más genérica \emph{Ingeniería Software Dirigida por Modelos}~\cite{} aplicado desde el punto de vista de la \emph{Teoría de Lenguajes Formales}. El proceso de de ingeniería de un nuevo lenguaje de modelado está compuesto de diversas fases, las cuales se explican con ayuda de la figura \ref{fig:sle:diagramaSLE}.

\begin{figure}[!tb]
    \includegraphics[scale=0.5]{introduction/slefig.eps}
    \caption{Componentes de la ingeniería de lenguajes dirigida por modelos}
    \label{fig:sle:diagramaSLE}
\end{figure}

%%===========================================================================================%%
%% NOTA(Pablo): No metas paja por meter, vamos a explicar directamente qué es la Inegniería  %%
%%              de lenguajes dirigida por modelos                                            %%
%%===========================================================================================%%
%%
%% Por tanto, con lo cual es conveniente explicar en qué consiste MDA y comentar los         %%
%% añadidos que introduce el enfoque gramático.                                              %%  %%
%% La Ingeniería Dirigida por Modelos intenta definir la funcionalidad de el sistema que
%% pretendemos crear a través de la creación de uno o varios metamodelos que representen
%% todas las características de nuestro sistema y todas las operaciones que puede llevar
%% a cabo. El principal objetivo de la Ingeniería Dirigida por Modelos es elevar el nivel
%% de abstracción aún más, situándolo por encima del límite establecido por los
%% Lenguajes de Alto Nivel.
%%
%%
%% El nivel de abstracción y complejidad de nuestros metamodelos variará dependiendo de
%% la cantidad de ellos que incorporemos al sistema. De este modo, un metamodelo que
%% represente todo el sistema directamente será más difícil de entender a primera vista
%% que varios metamodelos que implementen cada uno un tipo de operación o funcionalidad
%% del sistema.
%%
%% La transformación de esos modelos a código permite la automatización de tareas que
%% pueden resultar triviales y/o repetitivas al programador, en las cuales de otro modo
%% se invierte mucho tiempo de programación y de detección y depuración de errores.
%%
%%
%% Una vez que tengamos los metamodelos necesarios para definir el comportamiento de
%% nuestro sistema, podremos instanciarlos para crear modelos que representen sistemas
%% concretos. Una instancia de un metamodelo es un modelo que cumple todos los
%% requisitos marcados por su metamodelo, y que da valor a los parámetros del mismo
%%  (por ejemplo a sus atributos).
%%
%%===========================================================================================%%

\begin{enumerate}
	\item El primer paso es crear las reglas de construcción o sintaxis de nuestro lenguaje de modelado. Esto se realiza mediante la creación de un metamodelo, o modelo de nuestro lenguaje que describe usando conceptos parecidos a los de los diagramas de clases, la \emph{sintaxis abstracta} o reglas para la construcción de modelos de nuestro lenguaje. Dicho metamodelo se construye usando un lenguaje de metamodelado. Existen diversos lenguajes de metamodelado, tales como KM3 ~\cite{} o MOF ~\cite{}, aunque Ecore ~\cite{} está considerado como el estándar \emph{de facto} dentro de la comunidad de modelado. Normalmente no es posible especificar cualquier tipo de restricción entre los elementos de un lenguaje de modelado usando exclusivamente los elementos del lenguaje de metamodelado. Por ello, tales lenguajes de metamodelado se acompañan con un lenguaje de especificación de restricciones. OCL ~\cite{} es el lenguaje de restricciones más usado para desarrollar esta tarea.
	\item Como se ha comentado en el punto anterior, un metamodelo establece la sintaxis abstracta de nuestro lenguaje de modelado, pero no especifica la \emph{sintaxis concreta} o notación de nuestro lenguaje de modelado. Por tanto el siguiente paso en la ingeniería de un nuevo lenguaje de modelado, es la definición de una notación o sintaxis concreta para nuestro lenguaje. Esta notación puede ser tanto textual como gráfica. Para la definición de notaciones gráficas, GMF es la herramienta más popular cuando se trabaja con Ecore. Para notaciones textuales, TCS ~\cite{}, xText, TEF o EMFText pueden ser usadas, no existiendo aún un estándar \emph{de facto} para la definición de notaciones textuales.
	\item Por último, nos quedaría definir la semántica del lenguaje de modelado. Existen un amplio rango de técnicas para desarrollar esta tarea, tales como: (1) definir la semántica de cada elemento de manera informal; (2) especificar la semántica de cada elemento usando un lenguaje formal, tales como máquinas de estado abstractas, o (3) crear generadores que transformen los elementos de modelado en elementos de otro lenguaje distinto bien definido.
\end{enumerate}
%%===========================================================================================%%
%% NOTA(Pablo): Copia aquí la Sección 2.2 que aparece en la memoria de Hydra, disponible
%%              aquí: http://caosd.lcc.uma.es/spl/hydra/documents/PFC_JRSalazar.pdf
%%              Rehaz la Figura 2.9 en Visio o similar, y quitale la línea rizada.
%%===========================================================================================%%

\begin{figure}[!tb]
    \includegraphics[scale=0.5]{background/abstracta.eps}
    \caption{Metamodelo (sintaxis abstracta) de un lenguaje para modelar grafos pesados dirigidos}
    \label{fig:sle:metamodeloGrafo}
\end{figure}

Ilustramos los conceptos anteriormente expuestos mediante la creación de un lenguaje simple para el modelado de grafos dirigidos y pesados. La Figura~\ref{fig:sle:metamodeloGrafo} muestra el metamodelo o sintaxis abstracta para dicho lenguaje. La clase \emph{Grafo} actúa como contenedor para el resto de los elementos. Representa un como conjunto de \emph{Nodos} y \emph{Arcos}. Los nodos poseen nombre, que permite distinguirlos uno de otros. Dichos nodos pueden estar conectados por arcos dirigidos, por lo que cada arco tiene un nodo origen y un nodo destino. Dado que el grafo es pesado, cada noto tiene además un peso.

%%===========================================================================================%%
%% NOTA(Pablo): Esto es redundate, es decir, básicamente paja para rellenar                  %%
%%===========================================================================================%%
%%
%% En el ejemplo presentado, el metamodelo presenta la sintaxis abstracta de nuestro
%% sistema porque cualquier instanciación válida del mismo constituye un grafo completo.
%% Dentro del contexto particular de la Ingeniería de Lenguajes Dirigida por Modelos, la
%% sintaxis abstracta representa cualquier conjunto de líneas de código válidas que pueden
%% construirse a partir de ella, y posteriormente ser ejecutadas.
%%
%%===========================================================================================%%

%%===========================================================================================%%
%% NOTA(Pablo): En esta figura pega los nombres de las referencias y las multiplicidades a   %%
%%              los extremos de las asociaciones                                             %% %%===========================================================================================%%

\begin{figure}[!tb]
    \includegraphics[scale=0.35
]{background/concretaHabilidad.eps}
    \caption{Modelo abstracto de un grafo pesado dirigido concreto (Se han omitido las relaciones que van desde Grafo a cada uno de los Arcos en aras de aumentar la claridad de la figura)}
    \label{fig:sle:modeloAbstractoGrafo}
\end{figure}

Utilizando dicho metamodelo, que no es más que un diagrama de clases, podemos crear instancias del mismo. Una instancia de un metamodelo es un modelo. En nuestro caso, cada instancia concreta del metamodelo de la Figura~\ref{fig:sle:metamodeloGrafo} representaría un determinado grafo pesado dirigido, con un número determinado de nodos, pesos y arcos. Por ejemplo, la Figura~\ref{fig:sle:modeloAbstractoGrafo} muestra una instancia del metamodelo de la Figura~\ref{fig:sle:metamodeloGrafo} que representa un grafo dirigido y pesado cuyos nodos representan las habilidades de una determinada disciplina, mientras que el peso de los arcos representa el tiempo necesario para adquirir esa habilidad. La habilidad 1 es el nodo inicial, es decir, aquella que todos poseen. A partir de ahí y siguiendo los arcos se pueden desarrollar unas habilidades u otras.

%%===========================================================================================%%
%% NOTA(Pablo): Este ejemplo no es el mejor ejemplo de nodo dirigido, porque las distancias  %%
%%              entre ciudades son simétricas, es decir, si la distancia entre Barcelona y   %%
%%              Santander es de 600km, entre Santander y Barcelona también es de 600         %% %%===========================================================================================%%

%%===========================================================================================%%
%% NOTA(Pablo): Demasiado especializado                                                      %%     %%===========================================================================================%%
%%
%% Pero no sólo eso, el hecho de que estemos trabajando con lenguajes conlleva
%% irrevocablemente el tener que desarrollar una gramática de producciones para poder
%% construir nuestras líneas de código en el orden apropiado y con los símbolos apropiados.
%% Eso sí, la gramática será más sencilla y comprensible que la que habría que construir
%% de no estar usando este tipo de metodología. Esta tarea también queda englobada en la
%% sintaxis concreta. De este modo, la sintaxis concreta se suele clasificar en sintaxis
%% concreta visual (el modelo, expresado mediante líneas de código en el caso de lenguajes,
%% o un grafo pintado en el caso del ejemplo mostrado) y sintaxis concreta textual (la
%% gramática del lenguaje).
%%
%%===========================================================================================%%

Como se ha ilustrado con los ejemplos anteriores, un metamodelo define un conjunto de reglas que debe obedecer todo modelo que pertenezca al lenguaje definido por dicho metamodelo. Por tanto, usando términos más técnicos, un metamodelo define la sintaxis abstracta de un lenguaje. Dicha sintaxis abstracta será similar a los árboles sintacticos de los lenguajes de programación tradicionales. No obstante, para que el lenguaje definido por un metamodelo sea fácilmente utilizable, debemos definir una sintaxis concreta, ya sea textual o gráfica, para dicho lenguaje. Dicha sintaxis concreta indicaría como podemos construir modelos que sean conformes al metamodelo, pero usando una notación que le sea familiar al usuario, en lugar de la notación genérica y abstracta mostrada en la Figura~\ref{fig:sle:modeloAbstractoGrafo}.

\begin{figure}[!tb]
    \includegraphics[scale=0.5]{background/grafoHabilidad.eps}
    \caption{Modelo concreto de un grafo pesado dirigido concreto}
    \label{fig:sle:sintaxisVisual}
\end{figure}

Por ejemplo, para nuestro ejemplo anterior, el del lenguaje para la especificación de grafos dirigidos pesados, podríamos elaborar una sintaxis visual donde los grafos se representasen utilizando la notación visual por todos conocida, tal como se ilustra en la Figura~\ref{fig:sle:sintaxisVisual}. Dicha figura muestra el mismo modelo que la Figura~\ref{fig:sle:modeloAbstractoGrafo}, pero utilizando una sintaxis visual concreta. En este caso, las instancias de la clase \emph{Nodo} se representan como elipses. El nombre de cada nodo se muestra dentro de cada elipse. Las instancias de la clase \emph{Arco} se dibujan como flechas. La punta de la flecha indica cuál es el nodo destino, mientras que la cola especifica cuál es el nodo origen. El peso de cada arco se muestra como texto de forma adjunta a cada flecha.

Los modernos entornos para el desarrollo de lenguajes dirigido por modelos proporcionan facilidades para, una vez definido un metamodelo, asociar a cada clase perteneciente a dicho metamodelo, un símbolo gráfico. Utilizando las facilidades proporcionadas por dichos entornos es posible generar, de manera automática, un editor visual que permita la creación de modelos conformes al metamodelo origen, utilizando para ello la sintaxis visual definida. Ejemplos de tales entornos son MetaEdit+~\cite{}, Microsoft DSL tools~\cite{} o la conocida combinación de herramientas Eclipse+Ecore+GMF (\emph{Graphical Modelling Framework})~\cite{}.

De igual forma que hemos definido una sintaxis visual concreta hubiésemos podido definir una sintaxis textual concreta, donde los modelos conformes al metamodelo en cuestión pudiesen especificarse usando texto, en lugar símbolos gráficos. La Figura~\ref{fig:sle:sintaxisTextual} muestra el ejemplo de la Figura~\ref{fig:sle:modeloAbstractoGrafo} pero utilizando una sintaxis textual para nuestro lenguaje de grafos. En este caso, primero hay que definir un nombre para el grafo que estamos creando, y a continuación definir nodos y después arcos. De los nodos indicaremos su nombre, y de los arcos su peso y sus nodos de origen y destino, usando para ello las palabras reservadas pertinentes. De este modo podemos observar una de las claras ventajas de usar metamodelos para especificar lenguajes específicos de modelo, y es que permiten de forma relativamente sencilla poder expresar las sintaxis concretas de más de un modo, escogiendo para cada caso el que sea más conveniente.  %\todo{Describir}

\begin{figure}[!tb]
    \includegraphics[scale=0.3]{background/grafoTextual.eps}
    \caption{Sintaxis concreta textual de un grafo dirigido pesado}
    \label{fig:sle:sintaxisTextua}
\end{figure}

%%===========================================================================================%%
%% NOTA(Pablo): Crea un ejemplo para el caso de anterior y lo describes como el caso de la   %%
%%              sintaxis visual concreta                                                     %%
%%===========================================================================================%%

Al igual que en el caso de las sintaxis visuales concretas, los entornos de desarrollo de lenguajes dirigidos por modelos proporcionan facilidades para ligar los elementos de una gramática tipo BNF (\emph{Backus-Naus Form})~\cite{} con las clases de un metamodelo. Una vez establecida dicha relación, dichos entornos son capaces de generar un editor textual más un analizador sintáctico que permita la especificación de modelos conformes a nuestro modelo y su posterior análisis para su conversión en un modelo abstracto, como el mostrado en la Figura~\ref{fig:sle:modeloAbstractoGrafo}.

Una vez que hemos completado todos estos pasos somos capaces de elaborar modelos conformes a un determinado lenguaje, unívocamente especificado por un metamodelo. El último paso para definir de forma completa un lenguaje sería definir su semántica. Dependiendo del lenguaje que estemos creado, dicha semántica podría ser de diferentes tipos. Por ejemplo, para el caso de un lenguaje basado en Redes de Petri, la semántica podría ser una semántica dinámica que especifique como deben ejecutarse los modelos basados en Redes de Petri. Dicha semántica dinámica debería permitir construir sin ambigüedades un simulador o máquina virtual para dicho lenguaje.

En otros casos, la semántica podría definirse de forma \emph{translacional}, mediante la transformación del modelo en otro modelo con semántica bien definida. Este sería el caso, por ejemplo, de los lenguajes compilados, donde un programa escrito en un cierto lenguaje se transforma en un código ensamblador. En este caso la semántica quedaría implementada por medio de un compilador generador de código.

Por tanto, a modo de resumen, un proceso de desarrollo de un lenguaje software utilizando un enfoque dirigido por modelos está formado por los siguientes pasos:

\begin{enumerate}
    \item Definición del metamodelo que especifica la sintaxis abstracta de nuestro lenguaje de modelado.
    \item Definición de las restricciones adicionales que no pueden ser recogidas mediante la sintaxis propia del lenguaje de metamodelado utilizado.
    \item Definición de una sintaxis concreta, visual o textual, para el metamodelo definido.
    \item Generación (automática) del correspondiente editor, textual o gráfico.
    \item Definición de la semántica del lenguaje.
    \item Implementación de dicha semántica mediante la técnica que se considere más adecuada para ella (simulador, máquina virtual, generación de código).
\end{enumerate}

Una vez explicado cómo funciona la Ingeniería de Lenguajes Dirigida por Modelos estamos preparados para poder definir como se ha estructurado y desarrollado el presente Proyecto Fin de Carrera. Dicha planificación se presenta en la siguiente sección.

%%===========================================================================================%%
%% NOTA(Pablo): Esto no debe aparecer aún, es demasiado pronto                               %%
%%===========================================================================================%%
%%
%% Una vez se han explicado las bases de la Ingeniería de Lenguajes Dirigida por Modelos
%% vamos a proceder a mostrar y explicar muy brevemente el metamodelo usado para generar
%% las estructuras válidas de código para el lenguaje de especificación y validación de
%% restricciones que hemos creado en este PFC. Ese metamodelo corresponde a la figura
%% \ref{fig4}
%%  \begin{figure}[t]
%%  \includegraphics[scale=0.4]{background/metamodelo.eps}
%%  \caption{Metamodelo utilizado para la creación de nuestro lenguaje de
%%           especificación y validación de restricciones}
%%  \label{fig4}
%% \end{figure}
%%
%% La clase que engloba todo el conjunto resultante es Model. Un modelo puede tener
%% varias restricciones, y estas a su vez pueden tener varias operaciones booleanas
%% (ya que una restricción siempre tiene que evaluarse a true o false). Esas operaciones
%% booleanas se dividen en varios tipos: unarias (negación) , binarias (and, or, etc.),
%% de comparación ( mayor que, menor que, etc.). o de selección (all, any)
%% Los operandos pueden ser otras operaciones o características (en inglés Features).
%% Más adelante se explicará en detalle la sintaxis del lenguaje creado.
%%
%%===========================================================================================%%










