%%==================================================================%%
%% Author : Tejedo González, Daniel                                 %%
%%          Sánchez Barreiro, Pablo                                 %%
%% Version: 1.0, 27/11/2012                                         %%
%% Version: 2.0, 09/02/2013                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Gramática, Diseño                                                %%
%%==================================================================%%

Una vez han sido definidas las características que queremos que nuestra sintaxis textual posea, el siguiente paso es diseñar una gramática que se ajuste a ellas. EMFText es la herramienta que utilizaremos para implementar esta gramática.

El diseño de la gramática pasa por asignar una serie de reglas a las metaclases, de modo que EMFText sea capaz de reconocer esas reglas en las expresiones de nuestro lenguaje y asociarlas a la metaclase correspondiente. Cuando el el proceso de análisis de un texto EMFText detecta una regla, crea una instancia de la metaclase asociada, con los atributos correspondientes debidamente inicializados.

Además de las reglas, en EMFText hay que definir otra serie de claúsulas que permiten configurar ciertos aspectos de la gramática. Para explicar tanto estas directrices como las reglas de las metaclases nos apoyaremos en la gramática diseñada, la cual se muestra en la Figura~\ref{fig:initGram}.

\begin{figure}[!tb]
    \includegraphics[scale=0.35]{gramatica/iniciogram.eps}
    \caption{Gramática EMFText del lenguaje HCL (I)}
    \label{fig:initGram}
\end{figure}

La primera línea muestra la claúsula \emph{SYNTAXDEF}, que sirve para indicar la extensión que queramos que tengan los ficheros correspondientes a nuestro lenguaje. En nuestro caso, hemos elegido la extensión \emph{hydraconst}. A continuación, la directriz \emph{FOR} sirve para vincular la gramática con el metamodelo. La siguiente línea contiene la cláusula \emph{START}, que indica cuál es la metaclase inicial del metamodelo. En nuestro caso, dicha metaclase es \emph{Model}.

Las líneas 05-07 corresponden al bloque \emph{OPTIONS}. Dentro de este bloque EMFText permite especificar diversas opciones que configuran su funcionamiento. En nuestro caso solo hemos activado una opción, que permite usar los tokens, símbolos terminales, definidos por defecto en EMFText.

A continuación, líneas 09-12, se encuentra el bloque \emph{TOKENS}. Este bloque sirve para definir los tokens, símbolos terminales, que usaremos en nuestra gramática. El token \emph{DIGIT} representa un número natural, y el token \emph{DIRECCION} que representa una cadena de caracteres que pueden ser rutas a archivos. Además, usaremos el token predefinido \emph{TEXT} para las cadenas de caracteres.

A partir de este punto comienza la definición de las reglas de la gramática. El punto de inicio es la regla de la regla de la línea 16, que define la regla de producción para el símbolo \emph{Model}. Esto significa que los textos que escribamos en nuestros lenguajes han de empezar siguiendo esta regla. En ella se define que la primera línea de cualquier fichero de restricciones ha de empezar por la palabra reservada \emph{import}, y a continuación se introduce la dirección que contiene el modelo de características sobre el que queremos aplicar las restricciones. Esta dirección se define mediante un token \emph{DIRECCION} y se guarda en el atributo \emph{featureList} de la clase \emph{Model}. A continuación, aparecerán un número no acotado de restricciones, que se almacenan en el atributo \emph{constraints} de la clase \emph{Model}.

Las restricciones se derivan mediante la regla correspondiente a la metaclase \emph{Constraint} (línea 17). En ella simplemente se indica que una restricción ha de estar compuesta por un operador, pudiendo enmarcarse la restricción entre paréntesis. Dependiendo de la aridad de cada operador, éste tendrá que venir acompañado de diversos operandos. Las reglas de las líneas 18-21 sirven para implementar la prioridad en las operaciones, permitiendo la inclusión de paréntesis.

\begin{figure}[!tb]
    \includegraphics[scale=0.3]{gramatica/operaciones1.eps}
    \caption{Gramática EMFText del lenguaje HCL (II)}
    \label{fig:opersUno}
\end{figure}

La Figura~\ref{fig:opersUno} muestra la definición de las operaciones básicas, tanto lógicas como numéricas. Cada operador concreto se corresponde con una metaclase del metamodelo definido en la Figura~\ref{chap:metamodelo}. Las operaciones con contexto se definen mediante la regla de la línea 37 . En ella se indica que un contexto se compone un operador de contexto, que debe ser una \emph{MultipleFeature}, más una restricción, la cual debe de aparecer entre corchetes. Obsérvese, que aunque, por ejemplo, en la regla de las operaciones de contexto aparezca \emph{contextOp2} como el elemento que debe aparecer entre corchetes, de acuerdo a las reglas definidas por nuestro metamodelo, \emph{contextOp2} debe ser una \emph{constraint}. EMFText tiene en cuenta estas restricciones para ayudarnos a definir la gramática.

\begin{figure}[t]
    \includegraphics[scale=0.3]{gramatica/operaciones2.eps}
    \caption{Gramática EMFText del lenguaje HCL (III)}
    \label{fig:opersDos}
\end{figure}

Finalmente, se definen las operaciones de comparación, cuantificación y las primitivas del lenguaje, tal como ilustra la Figura~\ref{fig:opersDos}. 
Las reglas para las primitivas indican que son símbolos terminales, y que el token procesado debe almacenarse en un atributo de la correspondiente metaclase. Por ejemplo, una \emph{SimpleFeature} se representará como una cadena de caracteres que se almacenará en el atributo \emph{featureName} de la correspondiente metaclase. 

Con esto completaríamos la definición de la gramática que especifica nuestra sintaxis textual concreta. A continuación, utilizando las facilidades de EMFText, generamos un editor, un analizador para nuestro lenguaje, más la lógica necesaria para desplegar dichos elementos como un \emph{plug-in} para Eclipse. Tras ello, realizamos una serie de pruebas para probar su correcto funcionamiento. La siguiente sección describe dichas pruebas.

%La parte más trivial e inmediata del diseño de la gramática es la concerniente a la implementación de las operaciones, pues las producciones necesarias simplemente requieren la inclusión de los operandos involucrados y los caracteres que deseemos que definan la operación. La figura \ref{figopers} muestra la implementación de estas operaciones.
%
%\begin{figure}[t]
%\includegraphics[scale=0.35]{gramatica/iniciogram.eps}
%\caption{Implementación del inicio de la gramática con EMFText. Con la figura \ref{figopers} se completa la gramática}
%\label{figinitgram}
%\end{figure}
%
%\begin{figure}[t]
%    \includegraphics[scale=0.3]{gramatica/operaciones1.eps}
%    \caption{Implementación de las operaciones de nuestro editor com EMFText}
%    \label{figopers}
%\end{figure}
%
%Sí que cabe comentar con respecto a las operaciones las últimas líneas, que muestran la asignación de valor a las hojas de nuestros árboles parseados. En esas líneas estamos indicando que los atributos de las instancias de clase Number van a ser números, y que los atributos de las instancias de las clases SimpleFeature y MultipleFeature van a ser palabras.
%
%La parte más complicada corresponde a la implementación del inicio de la gramática y de las producciones que conducen a la misma. Pero antes de mostrar la figura con esta parte de la gramática conviene explicar el problema que llevó a realizar los cambios en el metamodelo mencionados en el capítulo anterior. Este problema surgió a la hora de implementar las operaciones con prioridad, es decir, la inclusión de los paréntesis.
%
%El inconveniente es que el tipo de gramática LL que implementa EMFText hacía imposible tomar una decisión sobre hacia qué elemento seguir parseando en caso de encontrarnos con un paréntesis. La mejor solución que se nos ocurrió para evitar este problema fue la adición de diversas clases y relaciones auxiliares en el metamodelo, cuya única función es estructural y de apoyo a la gramática. Gracias a ellas y a una mejor definición de las producciones conseguimos evitar esos problemas de parsing y podemos llevar a cabo las operaciones de prioridad con paréntesis.
%
%Las clases añadidas para solventar esta situación fueron las siguientes: BoolPriorityOperand1, BoolPriorityOperand2, NumPriorityOperand1, NumPriorityOperand2, BoolOperandChoices y NumOperandChoices. Las relaciones añadidas fueron boolPriorityOp1, boolPriorityOp2, numPriorityOp1 y numPriorityOp2.
%
%Una situación similar fue la que propició que las operaciones Context, All y Any hayan sido diseñadas tal y como presenta el metamodelo, ya que que la particular sintaxis de estas (diferente a las demás que siguen el mismo esquema de op + char + op) también mostraba ciertos problemas de parsing. En este caso no fue necesario añadir elementos auxiliares, sino simplemente recolocarlos para evitar estos problemas. Con esto ya se han hecho todos los cambios en el metamodelo, que alcanza en este punto su versión final tal como muestra la figura \ref{figmetameta}. Con respecto al metamodelo solamente quedan por comentar los métodos que muestran algunas clases, que serán explicados en los próximos capítulos ya que se usan en el proceso de validación y semántica.
%
%
%
%Una vez comentados estos detalles es momento de explicar el inicio de la gramática, que se muestra en la figura \ref{figinitgram}.
%
%En la primera línea y mediante la claúsula SYNTAXDEF indicamos la extensión que queremos que tengan los ficheros escritos en nuestro lenguaje. En nuestro caso nos hemos decantado por la terminación .hydraConst. En la segunda línea y mediante la claúsula FOR se indica la URI del metamodelo. Una URI es un formato de dirección interno de Eclipse, que se usa para localizar otros ficheros en el workspace. En la tercera línea, delimitada por la claúsula START, indicamos a la gramática que la clase inicial de nuestro metamodelo (y la que será la raiz en todos los árboles parseados) es Model.
%
%El bloque OPTIONS permite activar algunas opciones de configuración que incluye EMFText. En nuestro caso la única que tiene utilidad es usePredifinedTokens, que permite ahorrarnos la definición del token text. El bloque TOKENS sirve para definir los tokens de nuestra gramática. En nuestro caso usaremos 3: DIGIT para asignar al valor numérico, TEXT para asignar a las características y DIRECCION para asignar la dirección física del modelo de características.
%
%Por último, el bloque RULES permite crear las producciones. Como inicial, tal y como se especificó en los requisitos, exigimos un import y una dirección, que será almacenada en el atributo featureList de la clase Model. En la línea inicial también se indica, mediante una expresión regular, que el número de restricciones a definir puede ser tan grande como se desee y que estas deben acabar con el carácter '';'' .
%
%\begin{figure}[t]
%    \includegraphics[scale=0.3]{gramatica/operaciones2.eps}
%    \caption{Implementación de las operaciones de nuestro editor com EMFText}
%    \label{figopers}
%\end{figure}
%
%La línea de producción de Constraint diferencia entre operaciones con prioridad y sin ella. Sin el problema comentado de EMFText la gramática podría quedar así, pero para solucionarlo nos vemos obligado a incluir las cuatro líneas siguientes, cuya única función es solventar esa situación. El resto de la gramática continuaría en la figura \ref{figopers} mostrada anteriormente, y ahí terminaría.




