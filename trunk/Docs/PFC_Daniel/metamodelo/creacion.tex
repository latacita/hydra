%%==================================================================%%
%% Author : Tejedo González, Daniel                                 %%
%%          Sánchez Barreiro, Pablo                                 %%
%% Version: 1.0, 25/11/2012                                         %%                   
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Sintaxis abstracta, creacion metamodelo                          %%
%%==================================================================%%

Una vez hemos conocidos cuáles son los requisitos que debía satisfacer nuestro lenguaje, procedimos a construir un metamodelo en Ecore que cumpla tales requisitos. Dicho metamodelo se muestra en la Figura~\ref{figmetameta}.

%%==================================================================%%
%% NOTA(Pablo): Intenta meter esta figura de forma apaisada         %%
%%              Intenta que la figura se vea menos borrosa.         %%
%%              Intenta que la figura tenga menos cruces de linea   %% 
%%              ¿Es una captura de pantalla?                        %% 
%%==================================================================%%

\begin{figure}[!tb]
    \centerline{\includegraphics[scale=0.38, angle=90]{metamodelo/metamodelo.eps}}
    \caption{Metamodelo para el lenguaje HCL}
    \label{figmetameta}
\end{figure}

La clase \emph{Model} es la que sirve de punto de entrada y contender para el resto de las clases de nuestro metamodelo. 

Cómo se ha comentado anteriormente, debemos vincular un conjunto de restricciones con el árbol de características al cual deben aplicarse. Dicho árbol de características debe haber sido previamente creado usando la herramienta \emph{Hydra}, de acuerdo con los objetivos generales del proyecto. Eso reduce mucho el número de factores de los que hay preocuparse, viéndose reducidos en este punto a tener que almacenar únicamente la localización del fichero que contiene dicho árbol de característica, con objeto de poder cargarlo cuando se necesite. La ruta de dicho fichero se almacena en el atributo \emph{featureList} de la clase \emph{Model}.

Un modelo de restricciones permite especificar un número indeterminado de restricciones, representadas por la clase \emph{Constraint}. Por tanto, la clase \emph{Model} contendrá 0 o más restricciones (en principio se permiten definir ficheros sin restricciones, que se entiende se refinarán postriormente). 

Una restricción es una expresión booleana que se evalúa a vedadero o falso, y que contendrá un operador booleano, representando por la clase \emph{BoolOperand}, y varios operadores, representados por diversas clases. 

Un operador booleano puede ser tanto una \emph{SimpleFeature}, es decir, una característica no clonable, como una operación cuya evaluación de como resultado un valor booleano. Estas operaciones pueden ser lógicas (\emph{and}, \emph{or}, \emph{implies}, \emph{xor} y \emph{not}), de comparación ($<$, $<=$, $>$, $>=$, =, !=), de selección (\emph{all} y \emph{any}) o de contexto.

Por otro lado, una restricción también puede contener operadores numéricos. Un operador numérico puede ser una \emph{MultipleFeature}, es decir, una característica clonable, un número, o una operación cuya evaluación de como resultado un valor numérico. Estas operaciones son artiméticas, es decir, $+$, $-$, $*$ y $/$. El operador más prioritario de una restricción siempre ha de ser booleano, pues en última instancia esta tiene que poder ser evaluada a verdadero o falso.

Las operaciones lógicas y numéricas descritas están representadas en el metamodelo mediante las metaclases que llevan su nombre. Es decir, \emph{LessOrEqual} es la operación $<=$, \emph{Plus} es la operación $+$, y así sucesivamente. Se puede apreciar que estas metaclases son las hojas de una estructura de herencias. Esta estructura permite no solo facilitar la comprensión del metamodelo, sino también servir de apoyo a \emph{EMFText} en el momento de construir la posterior gramática. 

Como ejemplo, vamos a seguir esta estructura a través de una de las operaciones, \emph{Implies}. Esta metaclase hereda de \emph{BinaryOp}, que es la metaclase que representa las operaciones lógicas con dos operandos. \emph{BinaryOp} a su vez hereda de \emph{LogicalOperator}, que representa las operaciones lógicas. Por último, \emph{LogicalOperator} hereda de \emph{BoolOperand}, que representa los operadores booleanos. Un análisis análogo se podría realizar con cualquiera de las operaciones implementadas.

Cabe también mencionar algunas metaclases como \emph{BoolPriorityOperand1} que parecen ajenas a esta estructura y cuya presencia puede resultar dudosa. Su inclusión se justifica por razones de funcionamiento de la herramienta \emph{EMFText}, que requiere un tratamiento especial a la hora de implementar prioridad entre las operaciones.

Los atributos de las metaclases sirven para almacenar información importante para el lenguaje, que posteriormente podría ser utilizada a nivel de validación o ejecución. De estos atributos ya se ha mencionado la utilidad de \emph{featureList}, dentro de la clase \emph{Model}. Además de este, el atributo \emph{featureName} de las clases \emph{SimpleFeature} y \emph{MultipleFeature} sirve para almacenar el nombre de la característica a la que hagan alusión. Por último, el atributo \emph{numValue} de la clase \emph{Number} sirve para guardar el valor literal numérico que haya sido introducido.

%\todo{sigue tú describiendo el metamodel o en este estilo, describiendo su estructura sin entrar en detalles ni ponerte demasiado barroco. Describes lo que hay, no el proceso de cómo lo hiciste ni si te costó más o menos, o te pareció fácil o dificil. No describas las asociaciones entre metaclases, eso es demasiado detalle}.

%%========================================================================================%%
%% NOTA(Pablo): Todo lo de abajo quedará redundante con el nuevo texto, así que mejor     %%
%%              eliminarlo                                                                %% 
%%========================================================================================%%

%%========================================================================================%%
%% INICIO DE PARTE POSIBLEMENTE REDUNDANTE                                                %%
%%========================================================================================%%

%El primer paso es definir toda la estructura necesaria para la implementación de las operaciones, haciendo que cada una de ellas esté representada en nuestro metamodelo mediante una clase, pero sin preocuparnos todavía por las relaciones entre ellas. La clase raíz de toda esta estructura es Operand. Es una clase abstracta, es decir, en los modelos que luego instanciemos de este metamodelo no podrá haber ninguna instancia de Operand, sólo de los hijos no abstractos que tenga. A medida que vayamos definiendo clases hijas  de Operand estaremos especificando cada vez con más exactitud a qué tipo de operación estamos haciendo referencia.
%
%En el segundo nivel de la estructura de implementación de las operaciones hacemos una ramificación según el tipo del valor de retorno o de evaluación de las posibilidades. Es decir, a la clase Operand le añadiremos dos hijos: BoolOperand para operaciones que se evalúan a booleano y NumOperand para operaciones que se evalúan a numérico. Estas clases también serán abstractas.
%
%El proceso de división a partir de aquí es más o menos análogo para todas las operaciones, así que vamos a centrarnos únicamente en la rama que da lugar a las operaciones binarias lógicas, para comentar después los casos y situaciones especiales. Una vez tenemos la clase BoolOperand, podemos especializarla un poco más a LogicalOperator, que a su vez se dividirá en operaciones unarias, binarias, o de comparación. Todas ellas son clases abstractas. Por fin, la clase BinaryOp heredará las clases de las operaciones propiamente dichas, en este caso And, Or, Implies y Xor. Estas ya podrán ser instanciadas en las sintaxis concretas que creemos.
%
%Cabe hacer mención también a las clases SimpleFeature, MultipleFeature y Number, que representan a las características simples, múltiples y números respectivamente. En cualquier árbol resultante de parsear nuestro lenguaje, estas clases representarán las hojas. En última instancia todas las operaciones tendrán como operandos características o números. Podemos observar que SimpleFeature es un operando booleano (está en la parte estructural de las operaciones booleanas) ya que su evaluación será verdadero o falso, dependiendo si esa característica ha sido seleccionada en la configuración correspondiente o no. MultipleFeature sin embargo se evalúa a número entero. Su valor será el número de apariciones de esa característica dentro de la configuración correspondiente.
%
%Muchas de las clases que ahora se pueden contemplar en el metamodelo de la figura \ref{figmetameta} aún no estaban presentes en esta etapa temprana del diseño, y su inclusión fue necesaria a raíz de la creación de la gramática y los problemas que se observaron en ese punto. En particular, las terminadas en Choices y en PriorityOperand. Las operaciones All, Any y Context en este momento eran simples herencias de BoolOperand. El motivo de estas modificaciones será explicado en el capítulo siguiente.
%
%Para terminar este apartado, vamos a hablar de las relaciones entre las diferentes clases de nuestro metamodelo. En este punto del diseño no eran las mismas que las de la figura \ref{figmetameta} por los motivos explicados anteriormente. Simplemente buscábamos una forma de relacionar cada operación con los tipos de sus operandos (que también pueden ser operaciones, como es lógico). Las operaciones lógicas binarias tendrán dos operandos que también serán binarios. En este momento del diseño binaryOp1 y binaryOp2 iban relacionados a BoolOperand, al igual que unaryOp. Del mismo modo, compOp1, compOp2, numOp1 y numOp2 (es decir, los operandos de operaciones de comparación y numéricas respectivamente) estaban relacionados con la clase NumOperand.
%
%La relación de toda estructura de operaciones con los dos elementos anteriores, Model y Constraint, se realiza entre Constraint y BoolOperand. Toda restricción en última ha de ser evaluada a verdadero o falso, es por eso que la relación no va con Operand, como podría pensarse en primera instancia. De este modo estamos forzando que la operación con menos profundidad del árbol parseado de nuestra restricción sea booleana, y que por lo tanto el resultado final de validar la restricción sea un dato booleano.
%
%Quizás a alguien le pueda sorprender el hecho de que la relación ''operators'' entre Constrain y BoolOperand sea 1..1 y no 1..*. El motivo es que como los operadores de esa primera operación booleana que estamos forzando pueden ser a su vez operaciones, la complejidad en la restricción que podemos definir se propaga por ahí en lugar de por la relación creada.

%%========================================================================================%%
%% FIN DE PARTE POSIBLEMENTE REDUNDANTE                                                   %%
%%========================================================================================%%

Como se comentó en la Sección~\ref{sec:intr:sle}, no todas las restricciones que debe satisfacer un lenguaje pueden especificarse mediante la notación propia de un languaje de metamodelado. Para especificar dichas restricciones, se utilizan lenguajes complementarios al lenguaje propio de metamodelado. La siguiente sección explica como se definen dichas restricciones para nuestro lenguaje utilizando el EMF Validation Framework.


