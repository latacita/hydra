%============================================================================%
% Author: Pablo Sánchez                                                      %
%         p.sanchez@unican.es, http://personales.unican.es/sanchezbp         %
% Section : Discussion                                     Date: 01/03/2011  %
% Version : 1.0                                                              %
% Conference: SPLC 2011                                                      %
%============================================================================%

This paper has presented a new language with a well-defined semantics for expressing cross-constraints including clonable features. This language address the four research challenges identified in Section~\ref{sec:motivation}. Our language provides a meaning for clonable/multiple features, quantification operators and contexts. This language has been included  in our feature modelling tool called Hydra. This tool checks that multiple features are correctly used as simple features or multi valued features depending on the context where they appear. 

To validate this language, mainly its expressiveness, we have applied it to three case studies\footnote{The results can be found in \materialUrl}: (1) a SmartHome software product line based on an industrial case study~\cite{ample:d52}; (2) a graphical user interface, based on a domain specific language, presented in Santos et al~\cite{santos:2008}; a (3) the feature model for the satellite communication systems which initially motivated the addition of clonable features to feature models. We have modelled these case studies in Hydra and we have successfully specified the required cross-tree constraints. We would like to point out that the feature model for the Smart Home SPL is a good benchmark for analysing expressiveness of feature modelling tools since it was designed with this purpose at the beginning of the AMPLE project.

Moreover, we have presented in this paper how the constraints expressed in this language, which we have called \emph{Hydra Constraint Language},  can be transformed into a CSP problem to analyse them. Using this technique, we have implemented four analysis operations in Hydra. More specifically, we have implemented the \emph{valid configuration}, \emph{valid partial configuration}, \emph{void feature model}, \emph{dead features} and \emph{promising partial configuration} analysis operations~\cite{Benavides:2010}. We were particularly interested in the \emph{valid partial configuration}, since we were interested in discovering erroneous configurations as early as possible.

As already commented, the reader could argue a Domain-Specific Language (DSL) or Ecore-based model would be more useful for case studies like the Smart Home SPL than feature models with clonable features. Indeed, we explored both paths in the AMPLE project~\cite{ample:product,ample:solution}.

The rationale behind this argumentation is that DSL provides more user-friendly languages for configuring products. For instance, in the SmartHome case study, we might create a DSL (or metamodel) which specified that a automated house can have several floors and inside each floor, several rooms. Then, a visual (or textual) concrete syntax for this DSL might be created and the corresponding tooling developed or, in some cases, semi automatically generated. This visual syntax will clearly depict the containment relationships between floors and rooms, which would increase usability.

Whereas this argumentation is absolutely right, there also some counter argumentations. Fist of all, the visual editor for the DSL has to be developed. Although model-driven tools such as Eclipse GMF (Graphical Modelling Framework) has considerably simplified this task, this development time can not be neglected. Moreover, it requires a good expertise on model-driven techniques. It should also be noticed that a visual editor must be constructed per each case study. If feature models are used, this development time is saved, as designers only need to model a feature model using their favourite modelling tool.

Moreover, where some kind of variability can be nicely expressed using DSLs, other kinds, such as that a Room can optionally have several facilities, are not so nicely expressed. This purely configurative variability is added to DSLs y placing a set of boolean attributes on the DSLs model elements. These attributes are true is the feature has been selected; otherwise they are false. For instance, in the Smart Home case study, our DSL would have \imp{Room} as a model element that can be placed inside a \imp{Floor}. Each instance of \imp{Room} would have as boolean properties \imp{LightMng}, \imp{HeaterMng}, \imp{WindowMng} and \imp{SmartEnergyMng}. The user would have to set these properties to true or false depending on if he or she desires to select them.
Our experience has revealed that most users prefer to use feature model for carrying out this kind of configuration.

Finally, we would like to point out that, as it happens with feature model, no all relationships between elements of a certain domain can be specified in the metamodel that defines a DSL. Therefore, the specification of some external constraints is also required. These constraints are usually specifies using OCL. The main problem with OCL is this is not an easy to learn language. So, most users find difficulties for expressing constraints such as depicted in Figure~\ref{fig:constraints} in OCL. In addition, to carry out analysis operations using a set of constraints expressed in OCL is clearly more difficult than when expressed in other languages. The main reason is that OCL was not designed for supporting this kind of analysis operations, so they are difficult to implement using third-party tools for evaluating OCL expressions. Moreover, OCL has a large metamodel. Thus, to transform a set of OCL constraints into a CSP problem becomes more difficult than use a smaller metamodel, such as the one associated to the Hydra Constraint Language.

In general, we have noticed junior or young software designers used to model-driven technologies often prefer to use DSLs instead of feature models. On the other hand, feature models has been out there for 20 years, so senior software designers with a large experience on feature models are more likely to use clonable features rather than being into a new paradigm and learning new languages and tools, such as Ecore and GMF.

So, summarising, DSLs and feature models with clonable features have both advantages and disadvantages. According to our experience, when DSLs or feature models should be used is, in most of cases, just a matter of taste. Indeed, Ecore models can be transformed into feature models with clonable features, and feature models with clonable features can be transformed into Ecore models~\cite{stephan:2008}. So a possible solution for taking advantage of both solutions would be to use Ecore models as a basis for constructing user-friendly configuration tools and then map these models into feature models which can be analysed using the techniques presented through this paper. Thus, although based on feature models, the work presented in this paper is not incompatible with the use of DSLs.
