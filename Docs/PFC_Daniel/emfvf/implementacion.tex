%%==================================================================%%
%% Author : Tejedo González, Daniel                                 %%
%%          Sánchez Barreiro, Pablo                                 %%
%% Version: 1.0, 28/11/2012                                         %%
%% Version: 2.0, 06/02/2013                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Validation Framework, implementacion                             %%
%%==================================================================%%

La sintaxis propia de Ecore no nos permite especificar ciertas restricciones que debe satisfacer nuestro metamodelo. Dichas restricciones, las cuales se enumeran a continuación, deben comprobar que:

\begin{enumerate}
    \item La ruta que indica donde está el árbol de características al que se
        aplican las restricciones definidas es correctas. Ello implica comprobar tanto que la ruta es correcta como que el fichero que se halla en dicha ruta corresponde de verdad a un árbol de características.
    \item El atributo \emph{featureName} asociado a una \emph{SimpleFeature} o a una \emph{MultipleFeature} corresponde al nombre de una característica perteneciente al árbol de características referenciado.
    \item Una característica identificada como \emph{SimpleFeature} en el modelo de restricciones (evalúa a verdadero o falso) es realmente una característica simple (no clonable) en el árbol de características asociado. Sin esta comprobación, podríamos, por ejemplo, introducir características múltiples como operandos de operadores booleanas como \emph{and} u \emph{or}. En ese caso, sería imposible evaluar dichas operaciones ya que no podemos evaluar sus operandos a verdadero o falso.
\end{enumerate}

Respecto a la segunda restricción, merece la pena aclarar que el caso contrario, comprobar que una características considerada como múltiple en una restricción realmente lo sea, no es necesario controlarlo. La razón es que las características simples pueden tratarse como un caso particular o subtipo de característica múltiples, ya que siempre podremos considerarla como una característica clonable con cardinalidad $<0,1>$.

Para implementar estas restricciones externas se ha utilizado \emph{EMF Validation Framework}, herramienta integrada en EMF para este propósito concreto. Siguiendo las instrucciones proporcionadas por esta herramienta, añadimos un método de validación a cada metaclase que necesitaba ser validada. En nuestro caso, dichas clases eran \emph{Model}, \emph{SimpleFeature} y \emph{MultipleFeature}. De acuerdo con las normas establecida por \emph{EMF Validation Framework}, dichos métodos deben poseer un perfil concreto. Dicho perfil está compuesto por dos parámetros, uno llamado \emph{diagnostics} del tipo \emph{EDiagnosticChain} y otro llamado \emph{context} que es un mapa \todo{cual es la clave y cual es valor de este mapa?}. Los métodos de validación han de retornar siempre un valor booleano.

Si la validación es satisfactoria, el método debe obviamente devolver un valor verdadero. En caso contrario, retornará falso. El parámetro \emph{diagnostics} es un parámetro de salida que almacena información sobre el resultado de la validación, tal como el tipo de error producido o el mensaje de error que queremos mostrar al usuario.

%%==========================================================================================%%
%% NOTA(Pablo): Explicar para qué sirve el mapa                                             %%
%%==========================================================================================%%

Para implementar la primera restricción de las comentadas anteriormente, validar que la ruta que indica el árbol de características sea válida y apunte realmente a un árbol de características, se añadió un método de validación a la clase \emph{Model}. Para llevar a cabo esta validación simplemente se carga el fichero existente en la dirección indicada y se controla las posibles excepciones que una dirección errónea pueda generar. Además, se comprueba que el contenido de esa dirección sea un árbol de características. Se aprovecha también para generar una variable global que contenga el modelo leído, ya que será necesario volver a cargarlo en posteriores comprobaciones.

Para implementar la segunda restricción, comprobar que la existencia de las características escritas en nuestro fichero de restricciones en el árbol de características anteriormente asociado, añadimos métodos de validación a las metaclases \emph{MultipleFeature} y \emph{SimpleFeature}. Para ello simplemente buscamos que el nombre almacenado en el parámetro \emph{featureName} de dichas metaclases corresponda con el nombre de alguna características del modelo cargado anteriormente. 

Para implementar la segunda restricción, que las características identificadas como simples realmente sean realmente simples en el árbol de características asociado, añadimos un método de validación a la clase \emph{SimpleFeature}. Para realizar la comprobación tenemos que corroborar que ésta no pueda ser instanciada en más de una ocasión. Para ello tenemos que calcular la cota superior de su cardinalidad. Si dicha cota fuese mayor que uno, no sería una características simple. Este límite puede ser superior a uno en el caso de las características clonables, o de la características hijas de características múltiples. 

Tras añadir estas restricciones estaba definida la sintaxis abstracta para nuestro lenguaje. Antes de proceder a la definición de una sintaxis concreta para dicho lenguaje, realizamos una serie de pruebas destinadas a verificar que el metamodelo creado recoge la sintaxis abstracta deseada. 
