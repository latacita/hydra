Esta memoria de Proyecto Fin de Carrera presenta la ampliación de la aplicación Hydra, una herramienta para el modelado de características, desarrollada dentro del contexto del proyecto AMPLE, para lÃ­neas de productos software. Este capÃ­tulo introduce la situaciÃ³n anterior del proyecto Hydra y los conceptos implicados en el mismo. Se describirÃ¡n tambiÃ©n los objetivos que este trabajo pretende alcanzar y la motivaciÃ³n que subyace tras ellos. Por Ãºltimo, se indicarÃ¡ la estructura que presentarÃ¡ este documento. 1.1 IntroducciÃ³n La razÃ³n principal que motivÃ³ la creaciÃ³n de la herramienta Hydra es la ausencia de una aplicaciÃ³n completa para trabajar con LÃ­neas de Producto Software. El objetivo de una lÃ­nea de productos software es crear la infraestructura adecuada para una rÃ¡pida y fÃ¡cil producciÃ³n de sistemas software similares, destinados a un mismo segmento de mercado. Las lÃ­neas de productos software se pueden ver como anÃ¡logas a las lÃ­neas de producciÃ³n industriales, donde productos similares o idÃ©nticos se ensamblan y configuran a partir de piezas prefabricadas bien definidas, que son reutilizadas para la construcciÃ³n de productos similares. Un ejemplo clÃ¡sico es la fabricaciÃ³n de automÃ³viles, donde se pueden crear decenas de variaciones de un Ãºnico modelo de coche con un solo grupo de piezas cuidadosamente diseÃ±adas y una fÃ¡brica especÃ­ficamente concebida para configurar y ensamblar dichas piezas. Una pieza clave en la creaciÃ³n y desarrollo de una lÃ­nea de productos es el anÃ¡lisis y especificaciÃ³n de quÃ© elementos son comunes y quÃ© elementos son variables dentro del conjunto de productos similares producidos por la lÃ­nea de productos software. Para realizar dicha tarea se suelen construir modelos de caracterÃ­sticas[r, r, r]. Dichos modelos definen una descomposiciÃ³n jerÃ¡rquica, en forma de Ã¡rbol, de las caracterÃ­sticas de una serie de productos similares. Un caracterÃ­stica se define, de forma genÃ©rica, como un elemento visible del sistema, de interÃ©s para alguna persona que interactÃºa con el sistema, ya sea un usuario final o un desarrollador software[r]. Por ejemplo, una caracterÃ­stica de un coche serÃ­a su color. Una caracterÃ­stica puede ser descompuesta en varias subcaracterÃ­sticas que pueden ser obligatorias, opcionales o alternativas. Continuando con el mismo ejemplo, podemos entender que un utilitario convencional tiene obligatoriamente cuatro ruedas, puede opcionalmente tener GPS y se puede adquirir en una serie de colores alternativos. Para obtener un producto especÃ­fico, el usuario debe crear una configuraciÃ³n de este modelo de caracterÃ­sticas, es decir, una selecciÃ³n de caracterÃ­sticas que quiere que estÃ©n presentes en su producto. Una configuraciÃ³n o selecciÃ³n de caracterÃ­sticas debe de obedecer las reglas del modelo de caracterÃ­sticas. Por ejemplo, dentro de un conjunto de alternativas mutuamente excluyentes, como el color de un automÃ³vil, sÃ³lo una alternativa de entre todas las posibles debe ser seleccionada. Existen una serie de restricciones que no se pueden modelar con la sintaxis bÃ¡sicas de los modelos de caracterÃ­sticas. Un ejemplo de tales tipos de restricciones son las restricciones de implicaciÃ³n, que especifican que la selecciÃ³n de una caracterÃ­stica obliga a la selecciÃ³n de otra caracterÃ­stica diferente. Por ejemplo, la selecciÃ³n de GPS para un automÃ³vil podrÃ­a obligar a la inclusiÃ³n en dicho automÃ³vil de mandos integrados en el volante para el manejo tanto de la radio como del GPS. Estas restricciones se suelen modelar de forma externa al modelo de caracterÃ­stica, usando algÃºn tipo de formalismo adicional, como lÃ³gica proposicional. En el ejemplo planteado, la anterior restricciÃ³n se modelarÃ­a como una simple implicaciÃ³n entre caracterÃ­sticas. Surge por tanto un nuevo reto dentro del modelado de caracterÃ­sticas, que es la validaciÃ³n de las configuraciones respecto a tales restricciones externas. Por Ãºltimo, cabe destacar que en los Ãºltimos aÃ±os se ha aÃ±adido a los modelos de caracterÃ­sticas un simple pero importante concepto, como son las caracterÃ­sticas clonables[r], que son caracterÃ­sticas que pueden aparecer con un diferente nÃºmero o cardinalidad dentro de un producto. Por ejemplo, el modelo de caracterÃ­sticas de una casa puede tener como caracterÃ­stica clonable planta, dado que una casa posee un nÃºmero variable de plantas, es decir, usando nuestra terminologÃ­a, diferentes clones de la caracterÃ­stica planta. Esta ligera modificaciÃ³n hace que se pueda modelar variabilidad estructural, tal como que una casa tenga un nÃºmero variable de plantas, en los modelos de caracterÃ­sticas, acercando su potencia expresiva a la de los lenguajes de dominio especÃ­fico para lÃ­neas de producto software[r]. En la actualidad existen diversas herramientas para crear modelos de configuraciones, en su mayorÃ­a acadÃ©micas, tales como RequiLine[r] o fmp[r], siendo Ã©sta Ãºltima posiblemente la mÃ¡s conocida. No obstante, no existe ninguna herramienta en este momento que posea las siguientes caracterÃ­sticas de forma conjunta: 1- Una interfaz grÃ¡fica, amigable y que, en la medida de lo posible, asista al usuario en la creaciÃ³n de configuraciones. 2- Soporte el modelado y la configuraciÃ³n de caracterÃ­sticas clonables. 3- Permita la especificaciÃ³n de restricciones externas entre caracterÃ­sticas, incluyendo caracterÃ­sticas clonables. 4- Sea capaz de determinar si una determinada configuraciÃ³n es vÃ¡lida, es decir, no sÃ³lo obedece las reglas sintÃ¡cticas del modelo de caracterÃ­sticas, sino que tambiÃ©n se satisfacen las restricciones externas. Estas restricciones externas pueden estar definidas sobre caracterÃ­sticas clonables. Para resolver tales limitaciones de las herramientas actuales para el modelado de caracterÃ­sticas, hemos creado Hydra. Hydra es una herramienta para el modelado de caracterÃ­sticas que pretende proporcionar las siguientes funcionas: 1- Un editor completamente grÃ¡fico y amigable al usuario para la construcciÃ³n de modelos de caracterÃ­sticas; 2- un editor textual y una sintaxis propia para la especificaciÃ³n de restricciones entre caracterÃ­sticas; 3- Un editor grÃ¡fico, asistido y amigable al usuario para la creaciÃ³n de configuraciones de modelos de caracterÃ­sticas; 4- Un validador que comprueba que las configuraciones creadas satisfacen las restricciones definidas para el modelo de caracterÃ­sticas. En el momento de empezar este proyecto de fin de carrera Hydra ya tenÃ­a implementadas las funciones 1 y 3, pero aÃºn faltaban por implementar las funciones 2 y 4, labor de la que nos hemos hecho cargo en este proyecto. Para crear el lenguaje de dominio especÃ­fico que permita la especificaciÃ³n de restricciones externas entre caracterÃ­sticas se ha utilizado la tÃ©cnica de IngenierÃ­a de Lenguajes Dirigido Por Modelos. Esta tÃ©cnica esa una aproximaciÃ³n de la IngenierÃ­a Dirigida Por Modelos desde el punto de vista de la TeorÃ­a de Lenguajes Formales. La IngenierÃ­a Dirigida Por Modelos es una metodologÃ­a de desarrollo de software que se basa en la construcciÃ³n de la aplicaciÃ³n final a partir de uno o mÃ¡s modelos abstractos que representen el comportamiento y la funcionalidad de la misma. Mediante la modificaciÃ³n de los distintos parÃ¡metros configurables dentro de los modelos serÃ¡ posible la construcciÃ³n de herramientas diversas para un problema especÃ­fico de manera relativamente sencilla, bastando simplemente con crear una serie de instancias vÃ¡lidas de los modelos representativos de nuestra aplicaciÃ³n. La IngenierÃ­a Dirigida Por Modelos se puede usar para crear nuevos lenguajes de programaciÃ³n, especialmente DSLs o Lenguajes EspecÃ­ficos de Dominio. Basta con imaginar uno o varios metamodelos cuyas instancias vÃ¡lidas representen una lÃ­nea o estructura correcta de cÃ³digo. Estos metamodelos forman la llamada sintaxis abstracta de nuestro lenguaje, pues representan de manera abstracta todas las posibles representaciones grÃ¡ficas o textuales que podemos hacer dentro de ese lenguaje. A partir del metamodelo que representa la sintaxis abstracta podremos construir una serie de modelos que sean instancias del mismo. Esto se denomina la sintaxis concreta, es decir, la representaciÃ³n concreta de una de las mÃºltiples posibilidades de instanciaciÃ³n del modelo abstracto. De todos modos, si queremos que las palabras expresadas en nuestro lenguaje sean expresadas de otro modo aparte de mediante modelos, no nos veremos liberados de la tarea de tener que expresar una gramÃ¡tica formal con producciones, pero hace que la construcciÃ³n de la misma estÃ© acotada dentro de unos tÃ©rminos delimitados por el modelo construÃ­do, lo cual favorece la sencillez de la gramÃ¡tica y su comprensiÃ³n. Esta gramÃ¡tica servirÃ¡ para identificar si la creaciÃ³n de expresiÃ³n concreta a la que puede ser transformada es viable mediante el metamodelo abstracto. Una vez hemos construido los medios necesarios para comprobar que las expresiones que fabriquemos son correctas, necesitamos idear el modo de que las Ã³rdenes que esas lÃ­neas producen sean ejecutadas. Para ello entra en juego la semÃ¡ntica del lenguaje, es decir, la encargada de aportar un significado real a todas las expresiones que hayamos construido. Dicho de otro modo, la semÃ¡ntica es la encargada de implementar las funciones derivadas de las Ã³rdenes descritas por cada una de las sintaxis concretas posibles. Poniendo un ejemplo, el metamodelo que represente la sintaxis abstracta de java puede generar una infinidad de sintaxis concretas, entre ellas System.out.println("Hola Mundo"). Y para que esa instrucciÃ³n escriba el mensaje Hola Mundo por pantalla es necesaria una semÃ¡ntica que asÃ­ lo indique. Para implementar la semÃ¡ntica del lenguaje no existe otro mÃ©todo que la programaciÃ³n directa en un lenguaje determinado, en nuestro caso Java. Por Ãºltimo, cabe destacar que la herramienta Hydra se encuentra englobada dentro del proyecto AMPLE, financiado por la ComisiÃ³n Europea dentro del sexto Programa Marco. El objetivo principal de AMPLE es proporcionar una metodologÃ­a de desarrollo para lÃ­neas de productos software, que abarque desde la fase de ingenierÃ­a de requisitos hasta su implementaciÃ³n, que mejore: (1) la modularizaciÃ³n de los elementos variables de una lÃ­nea de productos software; (2) la gestiÃ³n de tales elementos variables y (3) la generaciÃ³n y mantenimiento de la informaciÃ³n sobre la trazabilidad de los diferentes artefactos de una lÃ­nea de productos software. 1.2 Objetivos Como ya se ha comentado en la secciÃ³n de introducciÃ³n, no existe ninguna herramienta que posea de forma conjunta una serie de elementos de interÃ©s para el modelado de LÃ­neas de Productos Software y Ãrboles de CaracterÃ­sticas. MÃ¡s concretamente, no existe ninguna herramienta que contemple el modelado, configuraciÃ³n y validaciÃ³n de caracterÃ­sticas clonables. Estas caracterÃ­sticas son imprescindibles para el modelado de la variabilidad estructural. Por lo tanto, el objetivo de Hydra siempre fue suplir esas carencias, en la medida de lo posible. Concretando mÃ¡s en concreto, los objetivos de Hydra se pueden clasificar en los 4 que se enumeran a continuaciÃ³n: 1. Desarrollar un editor completamente grÃ¡fico y amigable al usuario para la construcciÃ³n de modelos de caracterÃ­sticas, incluyendo soporte para el modelado de caracterÃ­sticas clonables. 2. Desarrollar un editor textual y una sintaxis propia para la especificaciÃ³n de restricciones entre caracterÃ­sticas, incluyendo restricciones que involucren caracterÃ­sticas clonables. 3. Desarrollar Un editor grÃ¡fico, asistido y amigable al usuario para la creaciÃ³n de configuraciones de modelos de caracterÃ­sticas, incluyendo soporte para la configuraciÃ³n de caracterÃ­sticas clonables. 4. Crear un validador que compruebe que las configuraciones creadas satisfacen las restricciones definidas para el modelo de caracterÃ­sticas, incluso cuando estas restricciones contengan caracterÃ­sticas clonables. La labor a desarrollar dentro del marco concreto de este proyecto de fin carrera fue continuar el proyecto Hydra donde se habÃ­a dejado anteriormente, es decir, una vez los objetivos 1 y 3 habÃ­an sido cumplimentados, pasar a implementar la funcionalidad correspondiente a los objetivos 2 y 4. Para satisfacer dichos objetivos, se realizaron las tareas que se describen a continuaciÃ³n: 1. Estudio del estado del arte. El objetivo de esta fase es adquirir los conceptos necesarios para comprender el contexto del proyecto Hydra, asÃ­ como los necesarios para continuar desarrollando la aplicaciÃ³n en el punto en que fue visitada por Ãºltima vez. MÃ¡s concretamente, ha sido fundamental familiarizarse con los conceptos de LÃ­nea de Producto Software, Ãrbol de CaracterÃ­sticas (con y sin caracterÃ­sticas clonables) y de IngenierÃ­a Dirigida por Modelos en general, y de IngenierÃ­a de Lenguajes Dirigida por Modelos en particular. 2. Estudio de las herramientas utilizadas. El objetivo de esta fase comprende la familiarizaciÃ³n con todas las herramientas y tecnologÃ­as necesarias para desarrollar la parte estipulada de la aplicaciÃ³n. En concreto, con EMF, Ecore, EMFText, Eclipse Validation Framework, Eclipse Plugin Development y Subversion. 3. Desarrollo de un editor de restricciones externas entre caracterÃ­sticas. El objetivo de este editor es soportar la especificaciÃ³n de restricciones externas ante un modelo de caracterÃ­sticas proporcionado por el usuario. Tales restricciones son expresiones similares a fÃ³rmulas lÃ³gicas, salvo por alguna peculiaridad especÃ­fica. Es por eso que se optÃ³ por el uso de un editor textual en lugar de uno grÃ¡fico, ya que es el mÃ©todo mÃ¡s habitual de representar este tipo de operaciones. Para crear el metamodelo del lenguaje se ha utilizado la herramienta Ecore, mientras que para definir la gramÃ¡tica se ha utilizado EMFText. 4. Desarrollo de un validador de configuraciones. Una vez se finalizÃ³ de crear el editor para las restricciones, el siguiente paso lÃ³gico era aportarle una semÃ¡ntica que permitiera comprobar si las restricciones creadas satisfacen la configuraciÃ³n proporcionada por el usuario. Para implementar la semÃ¡ntica se utilizaron las herramientas EMF, Eclipse Validation Framework y Eclipse Plugin Development. 5. ValidaciÃ³n y pruebas. Con objeto de evaluar, probar y verificar el correcto funcionamiento de nuestra herramienta se han sometido algunas configuraciones del Ã¡rbol de caracterÃ­sitcas Smarthome a una serie de pruebas de caja negra, tratando de probar todas las operaciones de restricciones posibles en todos los contextos problemÃ¡ticos y habituales. 1.3 Estructura del documento Tras este capÃ­tulo de introducciÃ³n, la memoria se estructura tal y como se describe a continuaciÃ³n: El capÃ­tulo 2 introduce un poco mÃ¡s en profundidad los conceptos implicados en la herramienta Hydra, asÃ­ como las herramientas mÃ¡s determinantes a la hora de llevar a cabo su implementaciÃ³n. El capÃ­tulo 3 describe la planificaciÃ³n del proyecto desde el punto de vista de las tareas involucradas. El capÃ­tulo 4 describe en profundidad la parte correspondiente a la creaciÃ³n de las sintaxis concreta y abstracta. El capÃ­tulo 5 describe el resto de tareas que se han llevado a cabo en el proyecto, y el capÃ­tulo 6 describe mis conclusiones personales y la situaciÃ³n de la herramienta de cara al futuro. 