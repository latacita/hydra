%%==================================================================%% 
%% Author : Tejedo González, Daniel                                 %% 
%%          Sánchez Barreiro, Pablo                                 %% 
%% Version: 1.0, 14/11/2012                                         %%                   %%                                                                  %% 
%% Memoria del Proyecto Fin de Carrera                              %% 
%% Introducción/Introducción                                        %% %%==================================================================%%

%%==================================================================%%
%% NOTA(Pablo): No te puedes lanzar tan directamente al tema, hay   %%
%%              que contextualizarlo un poco. Tienes que empezar    %%
%%              hablando de las líneas de productos software, luego %%
%%              de los árboles de características, luego de los     %%
%%              árboles de características con cardinalidad y por   %%
%%              último del problema de la validación de             %%
%%              restricciones.                                      %%
%%                                                                  %%  
%%              Sigue el esquema del anteproyecto, disponible en:   %%
%%              https://pfcciencias.unican.es/node/170              %%
%%==================================================================%%

El principal objetivo de este Proyecto de Fin de Carrera es continuar el desarrollo de la herramienta Hydra allá dónde se dejó. Pero para entender un poco mejor las características del entorno que aquí se ha desarrollado conviene explicar un poco las razones que motivaron la creación del proyecto Hydra en primera instancia. Desde su nacimiento, Hydra ha pretendido convertirse en la aplicación más completa para trabajar con Líneas de Producto Software, dado que no existe ninguna que ofrezca una serie de características de manera conjunta. Trabajar con Líneas de productos software conlleva a su vez trabajar con una nada desdeñable cantidad de conceptos íntimamente vinculados a ellas. En los próximos párrafos se describirá lo que es una línea de productos software y los conceptos subyacentes que nos permiten trabajar con ellas.

El objetivo de una línea de productos software es crear la infraestructura adecuada para una rápida y fácil producción de sistemas software similares, destinados a un mismo segmento de mercado. Las líneas de productos software se pueden ver como análogas a las líneas de producción industriales, donde productos similares o idénticos se ensamblan y configuran a partir de piezas prefabricadas bien definidas, que son reutilizadas para la construcción de productos similares. Un ejemplo clásico es la fabricación de automóviles, donde se pueden crear decenas de variaciones de un único modelo de coche con un solo grupo de piezas cuidadosamente diseñadas y una fábrica específicamente concebida para configurar y ensamblar dichas piezas.

Una pieza clave en la creación y desarrollo de una línea de productos es el análisis y especificación de qué elementos son comunes y qué elementos son variables dentro del conjunto de productos similares producidos por la línea de productos software. Para realizar dicha tarea se suelen construir modelos de características ~\ref{} ~\ref{} ~\ref{}. Dichos modelos definen una descomposición jerárquica, en forma de árbol, de las características de una serie de productos similares. Un característica se define, de forma genérica, como un elemento visible del sistema, de interés para alguna persona que interactúa con el sistema, ya sea un usuario final o un desarrollador software ~\ref{}. Por ejemplo, una característica de un coche sería su color. Una característica puede ser descompuesta en varias subcaracterísticas que pueden ser obligatorias, opcionales o alternativas. Continuando con el mismo ejemplo, podemos entender que un utilitario convencional tiene obligatoriamente cuatro ruedas, puede opcionalmente tener GPS y se puede adquirir en una serie de colores alternativos. Para obtener un producto específico, el usuario debe crear una configuración de este modelo de características, es decir, una selección de características que quiere que estén presentes en su producto.

Una configuración o selección de características debe de obedecer las reglas del modelo de características. Por ejemplo, dentro de un conjunto de alternativas mutuamente excluyentes, como el color de un automóvil, sólo una alternativa de entre todas las posibles debe ser seleccionada. Existen una serie de restricciones que no se pueden modelar con la sintaxis básicas de los modelos de características. Un ejemplo de tales tipos de restricciones son las restricciones de implicación, que especifican que la selección de una característica obliga a la selección de otra característica diferente. Por ejemplo, la selección de GPS para un automóvil podría obligar a la inclusión en dicho automóvil de mandos integrados en el volante para el manejo tanto de la radio como del GPS. Estas restricciones se suelen modelar de forma externa al modelo de característica, usando algún tipo de formalismo adicional, como lógica proposicional. En el ejemplo planteado, la anterior restricción se modelaría como una simple implicación entre características. Surge por tanto un nuevo reto dentro del modelado de características, que es la validación de las configuraciones respecto a tales restricciones externas.

Por último, cabe destacar que en los últimos años se ha añadido a los modelos de características un simple pero importante concepto, como son las características clonables ~\ref{}, que son características que pueden aparecer con un diferente número o cardinalidad dentro de un producto. Por ejemplo, el modelo de características de una casa puede tener como característica clonable planta, dado que una casa posee un número variable de plantas, es decir, usando nuestra terminología, diferentes clones de la característica planta. Esta ligera modificación hace que se pueda modelar variabilidad estructural, tal como que una casa tenga un número variable de plantas, en los modelos de características, acercando su potencia expresiva a la de los lenguajes de dominio específico para líneas de producto software ~\ref{}.

En la actualidad existen diversas herramientas para crear modelos de configuraciones, en su mayoría académicas, tales como RequiLine ~\ref{} o fmp ~\ref{}, siendo ésta última posiblemente la más conocida. No obstante, no existe ninguna herramienta en este momento que posea las siguientes características de forma conjunta:

1- Una interfaz gráfica, amigable y que, en la medida de lo posible, asista al usuario en la creación de configuraciones.
2- Soporte el modelado y la configuración de características clonables.
3- Permita la especificación de restricciones externas entre características, incluyendo características clonables.
4- Sea capaz de determinar si una determinada configuración es válida, es decir, no sólo obedece las reglas sintácticas del modelo de características, sino que también se satisfacen las restricciones externas. Estas restricciones externas pueden estar definidas sobre características clonables.

Para resolver tales limitaciones de las herramientas actuales para el modelado de características, hemos creado Hydra. Hydra es una herramienta para el modelado de características que pretende proporcionar las siguientes funcionas:

1- Un editor completamente gráfico y amigable al usuario para la construcción de modelos de características;
2- un editor textual y una sintaxis propia para la especificación de restricciones entre características;
3- Un editor gráfico, asistido y amigable al usuario para la creación de configuraciones de modelos de características;
4- Un validador que comprueba que las configuraciones creadas satisfacen las restricciones definidas para el modelo de características.

En el momento de empezar este proyecto de fin de carrera Hydra ya tenía implementadas las funciones 1 y 3, pero aún faltaban por implementar las funciones 2 y 4, labor de la que nos hemos hecho cargo en este proyecto.

Para crear el lenguaje de dominio específico que permita la especificación de restricciones externas entre características se ha utilizado la técnica de Ingeniería de Lenguajes Dirigido Por Modelos. Esta técnica esa una aproximación de la Ingeniería Dirigida Por Modelos desde el punto de vista de la Teoría de Lenguajes Formales. La Ingeniería Dirigida Por Modelos es una metodología de desarrollo de software que se basa en la construcción de la aplicación final a partir de uno o más modelos abstractos que representen el comportamiento y la funcionalidad de la misma. Mediante la modificación de los distintos parámetros configurables dentro de los modelos será posible la construcción de herramientas diversas para un problema específico de manera relativamente sencilla, bastando simplemente con crear una serie de instancias válidas de los modelos representativos de nuestra aplicación.

La Ingeniería Dirigida Por Modelos se puede usar para crear nuevos lenguajes de programación, especialmente DSLs o Lenguajes Específicos de Dominio. Basta con imaginar uno o varios metamodelos cuyas instancias válidas representen una línea o estructura correcta de código. Estos metamodelos forman la llamada sintaxis abstracta de nuestro lenguaje, pues representan de manera abstracta todas las posibles representaciones gráficas o textuales que podemos hacer dentro de ese lenguaje.

A partir del metamodelo que representa la sintaxis abstracta podremos construir una serie de modelos que sean instancias del mismo. Esto se denomina la sintaxis concreta, es decir, la representación concreta de una de las múltiples posibilidades de instanciación del modelo abstracto. De todos modos, si queremos que las palabras admitidas por nuestro lenguaje sean expresadas de otro modo aparte de mediante modelos, no nos veremos liberados de la tarea de tener que expresar una gramática formal con producciones, pero hace que la construcción de la misma esté acotada dentro de unos términos delimitados por el modelo construído, lo cual favorece la sencillez de la gramática y su comprensión. Esta gramática servirá para identificar si la creación de expresión concreta a la que puede ser transformada es viable mediante el metamodelo abstracto. 

Una vez hemos construido los medios necesarios para comprobar que las expresiones que fabriquemos son correctas, necesitamos idear el modo de que las órdenes que esas líneas producen sean ejecutadas. Para ello entra en juego la semántica del lenguaje, es decir, la encargada de aportar un significado real a todas las expresiones que hayamos construido. Dicho de otro modo, la semántica es la encargada de implementar las funciones derivadas de las órdenes descritas por cada una de las sintaxis concretas posibles. Poniendo un ejemplo, el metamodelo que represente la sintaxis abstracta de java puede generar una infinidad de sintaxis concretas, entre ellas System.out.println("Hola Mundo"). Y para que esa instrucción escriba el mensaje Hola Mundo por pantalla es necesaria una semántica que así lo indique. Para implementar la semántica del lenguaje no existe otro método que la programación directa en un lenguaje determinado, en nuestro caso Java.

Por último y para terminar esta introducción, conviene contextualizar un poco el trabajo que hemos hecho mediante un ejemplo concreto de lo que se quiere implementar. Nuestro editor para la especificación y validación de restricciones en árboles de características con características clonables tiene que implementar la siguiente funcionalidad:

1 - Obligar a que todas los ficheros de restricciones empiecen con una línea de import que servirá para importar el modelo de características sobre el cual se analizarán las restricciones.
2 - Escribir restricciones válidas para ese modelo (ejemplo: "(a or b) implies (c and d);", más adelante se hablará en detalle del lenguaje y de las operaciones que implementa).
3 - Detectar que las características a las que estamos aplicando esas restricciones en efecto se hallan en el modelo que ha sido importado
4 - Cargar una instancia de ese modelo (lo que llamamos modelo de especialización) y mirar si para ella las restricciones que han sido especificadas se cumplen.
