%%==================================================================%%
%% Author : Tejedo González, Daniel                                 %%
%%          Sánchez Barreiro, Pablo                                 %%
%% Version: 1.0, 25/11/2012                                         %%
%% Version: 2.0, 06/02/2013                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Sintaxis abstracta, requisitos                                   %%
%%==================================================================%%

El primer paso para desarrollar nuestro lenguaje era conocer qué aspecto debía tener nuestro lenguaje y qué restricciones debía satisfacer. Es decir, en primer lugar debemos realizar un proceso que podemos denominar de captura de requisitos para poder comprender qué es lo que tiene que hacer exactamente el lenguaje que se pretende crear.

Concretamente nuestro lenguaje había sido prácticamente definido por el profesor Pablo Sánchez, del Departamento de Matemáticas, Estadística y Computación de la Universidad de Cantabria, mediante notación BNF. Dicha gramática, se muestra en la Figura~\ref{fig:constraintBNF}. Las ideas subyacentes a dicho lenguaje son las que se describen a continuación. 

\begin{figure}[!tb]
    \includegraphics[scale=0.3]{metamodelo/constraintBNF.eps}
    \caption{Gramática en notación BNF del lenguaje HCL}
    \label{fig:constraintBNF}
\end{figure}

En dicho lenguaje, una \emph{restricción} es una expresión lógica que se puede evaluar a verdadero o falso. Una restricción puede ser simplemente un literal, es decir, $true$ o $false$, que se evaluará a verdadero y falso respectivamente. Una restricción también puede ser una característica simple, es decir, una característica que puede aparecer en las configuraciones como máximo una vez. Una característica simple se evalúa a verdadero si ha sido seleccionada, y a falso en caso contrario.

Las características clonables son aquellas que pueden ser seleccionadas más de una vez en las configuraciones que construyamos sobre nuestro árbol de características. Una característica clonable se evalúan como un número entero positivo, incluido el cero. Ese número representa el número de clones que la característica posee dentro de una configuración, o dicho de otro modo, el número de veces que ha sido seleccionada. El hecho de que se evalúen como si fueran números permite la inclusión de operaciones de comparación entre distintas características clonables. Las operaciones de comparación que se han de implementar son las siguientes: $<$,$<$=,$>$,$>=$,$=$,$!=$. Además, también se puede utilizar el valor de las características clonables para implementar operaciones aritméticas básicas, tales como la suma, la resta, la multiplicación y la división. Estas expresiones a su vez se pueden utilizar como subexpresiones, u operandos, dentro de las operaciones de comparación. Las expresiones de comparación se evalúan a verdadero o falso, y también pueden ser usadas como subexpresiones para crear expresiones lógicas más complejas.

%%============================================================================%%
%% NOTA(Pablo) : Poner un ejemplo de este tipo de restricciones y explicarlas %%
%%============================================================================%%

Tal y como muestra la Figura~\ref{fig:constraintBNF}, una restricción también puede especificar un contexto concreto en el que poder evaluarla. Esto puede hacerse de varias maneras. Se puede especificar un contexto para una restricción poniéndola entre corchetes y especificando el nombre de una característica al principio de la expresión. La característica usada como contexto puede ser tanto simple como múltiple. En el primer caso, la restricción sólo será evaluada en el subárbol de la configuración cuya raíz sea la característica especificada.

%%============================================================================%%
%% NOTA(Pablo) : Poner un ejemplo y explicarlo                                %%
%%============================================================================%%

En el segundo caso entran en juego los operadores $all$ (para todo) y $any$ (existe). La operación $all$ solo se evaluará a verdadero si la restricción entre corchetes se cumple para todas las instancias de la característica clonable que actúa como contexto. En caso contrario, la operación se evaluará a falso. La operación $any$ se evaluará a verdadero si la restricción entre corchetes se cumple al menos una vez para todas las instancia de la característica clonable que actúa como contexto. Si la restricción no se cumple para ninguna de las selecciones, la operación $any$ se evaluará a falso.

%%============================================================================%%
%% NOTA(Pablo) : Poner un ejemplo y explicarlo                                %%
%%============================================================================%%

Merece la pena señalar que una característica puede ser considera simple en un contexto determinado y clonable o múltiple en otro. Por ejemplo, la característica $LightMng$ es clonable en el contexto de $RoomFacilities$, pero simple en el contexto de $GeneralFacilities$. Debido a eso la característica $LightMng$ no puede ser utilizada sin especificar el contexto en el que está ubicada, pues podría provocar un resultado no esperado o erróneo.

En la restricción $any Room[RoomFacilities[LightMng]]$ se pueden apreciar los dos diferentes usos para la operación de contexto. Los corchetes externos indican a la operación any que hay que aplicar la restricción a todas las habitaciones. Los corchetes internos indican que la característica $LightMng$ a la que se está haciendo referencia es la hija de $RoomFacilities$ y no cualquier otra.

Además nuestro lenguaje debía permitir vincular un modelo de características sobre el cual se definirán un conjunto de restricciones externas. Este modelo se utilizará, por ejemplo, para comprobar que los símbolos que aparecen como nombres de características en las restricciones se refieren a características que realmente existen en el árbol de características. Por ejemplo, una restricción del tipo $AdvancedHeating => Heating$ carecería de sentido si algunas de las características $AdvancedHeating$ o $Heating$ no apareciesen en el árbol de características sobre el cual estamos definiendo restricciones.

%%======================================================================================%%
%% NOTA(Pablo): Esto posiblemente sobre al introducir la traducción de la Sección III.
%%              Si es así, eliminarla.
%%              Si los conceptos de restricción con contexto y operación cuantificada
%%              no apareciesen, meter esta clasificación pero resumida
%%======================================================================================%%
%%
%% De entre todos esos requisitos básicos, es necesario entrar en detalle en el número 3
%% y enumerar la lista de operaciones que pueden ser definidas por nuestro lenguaje. Se
%% pueden clasificar en los siguientes tipos: \\
%%
%% - Lógicas: Son operaciones cuyos operandos han de ser características sin
%%   cardinalidad (también llamadas características simples), y que se evaluan a
%%   verdadero o falso. Entre las operaciones lógicas encontramos las clásicas not,
%%   and, or, xor e implica.
%%
%% - Numéricas: Sus operandos han de ser características con cardinalidad (también
%%   llamadas características múltiples) o simplemente números. Su resultado se evalua
%%   con un valor numérico. Las operaciones numéricas a implementar son la suma, resta,
%%   multiplicación y división.
%%
%% - Comparativas: Sus operandos han de ser características múltiples o simplemente números,
%%   pero su resultado se evalua con un valor booleano. Las operaciones de comparación a
%%   implementar son igual que, mayor que, menor que, distinto que, mayor o igual que y menor
%%   o igual que.
%%
%% - Operación de contexto: Operación que permite hacer referencia a una característica
%%   hija de otra característica. Esta operación tiene sentido para seleccionar
%%   características cuyo nombre pueda estar repetido pero que tengan contextos diferentes.
%%   Por ejemplo, en el modelo de características SmartHome de la figura \ref{figsmarthome}
%%   podemos observar que la característica HeaterMng está presente en muchos contextos
%%   diferentes. Esta operación es necesaria para poder saber con seguridad a cual de esos
%%   contextos estamos aplicando la restricción.
%%
%% - Operación de selección: Operación que corresponde a los operadores lógicos clásicos
%%   "para todo" o "existe", y que tiene la misma funcionalidad. Evalua si una restricción
%%   se cumple para todos los casos en que puede existir  o si se cumple en alguno de los
%%   casos. Por ejemplo, en el modelo de la figura \ref{figsmarthome} se podría evaluar una
%%   restricción para cada una de las habitaciones que hayan sido definidas, y saber si se
%%  cumple en todas, en alguna o en ninguna.
%%
%%======================================================================================%%

Utilizando esta información como base, procedimos a crear el correspondiente metamodelo en Ecore para nuestro lenguaje.


